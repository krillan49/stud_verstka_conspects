/*                                         Flexbox(позиционирование блоков) */

/* https://tpverstak.ru/flex-cheatsheet/                 - шпаргалга, быстрый тест элементов и свойств */
/* https://www.w3.org/TR/css-flexbox-1/#flex-containers  - оф документация */

/* Flexbox свойства позволяют позиционировать блоки адаптивно под разные размеры и типы экранов, при этом не высчитывать вручную их ширину и отступы. Позволяет легко менять очередность элементов в css коде не изменяя html */

/* Наиболее уместно использовать свойства Flexbox, когда элементы нужно расположить на одной оси */

/* responsive-дизайн - одинаково хорошо отображается на разных типах и размерах экранов */



/* Общие стили для элементов которые будут использованы для примеров с Flexbox */

* { padding: 0; margin: 0; }

.container-1 div, .container-2 div, .container-3 div { /* вложенные блоки для всех трех материнских блоков */
  padding: 10px;
  border: 1px solid silver;
}
.container-1 div { color: blue; border-color: blue; background-color: lightblue; }
.container-2 div { color: green; border-color: green; background-color: lightgreen; }
.container-3 div { color: red; border-color: red; background-color: lightyellow; }

h1 { text-align: center; background-color: silver;}


/*                                              Стили Flexbox */

.container-1 { /* родительский блок */
  display: flex; /* применяет flex к родительскому блоку, теперь внутренние блоки будут расположены горизонтально друг за другом*/
  /* автоматически высота всех болоков будет такой, чтоб умещались все элементы внутри этих блоков и приравняется к высоте макстимального из блоков, например после текста добавится пустое место внутри блоков чтоб все блоки были равны по высоте */
  align-items: stretch; /* align-items - флекссвойство изменяющее выравнивание блоков по высоте:
  flex-start - не будет выравнивания по высоте блоки прижаты к верху материнского блока;
  flex-end - прижаты к низу;
  center - выровнены по центру относительно максимального блока;
  stretch - значение по умодчанию как без свойства align-items */
  flex-direction: row; /* flex-direction - меняет расположение вложенных блоков:
  column - вертикально;
  column-reverse - вертикально в обратном порядке;
  row - горизонтально (значение по умолчанию);
  row-reverse - горизонтально в обратном порядке */
}

.box-1 {
  flex: 2; /* устанавливает относительную ширину(2 в 2 раза больше чем 1 итд) относительно других блоков в линии. При изменении ширины блоки автоматически заново выравниваются по высоте. Если указано только для одного элемента то он заполнит все свободное пространство(не занятое другими блоками) в линии */
  order: 2; /* флекссвойство меняющее порядок блоков в линии. В данном случае перемещаем блок на 2ю позицию слева (но только если у других блоков позиция тоже задана иначе переместится на крйнюю правую позицию) */
}

.box-2 {
  flex: 1;
  order: 1;
}

.box-3 {
  flex: 1;
  order: 3;
}


/* Удобно использовать с медиасвойствами для изменения расположения и вида блоков для разных типов экранов */
@media (min-width: 700px) {  /* медиасвойство добавляющее адаптивность блоку - при уменьшении максимальной ширины экрана или просто отображении на экране менее чем 700px вложенный блок свойств применяться не будет, те блоки расположатся по умолчанию один за одним вместо того чтоб отображаться тоненькими сосисочками */
  .container-2 { /* второй родительский блок */
    display: flex;
    justify-content: space-between; /* justify-content - свойство позиционирующее внутренние блоки если их совокупная ширина(ниже указываем) не занимает всю ширину нашего материнского блока(ширина указана дополнительно):
    flex-start - позиционирует прижатыми слева(значение по умолчанию);
    flex-end - справа;
    center - прижаты по центру;
    space-around - к каждому блоку добаляются отступы с обоих сторон такой ширины чтоб все пространство материнского блока было занято;
    space-between - аналогтчен предыдущему, только не добавляет 2 карайних отступа у крайних блоков */
  }
}

/* flex-basis - свойство аналогичное свойству width, при работе с Flexbox лучше использовать его. */
.box { flex-basis: 20%; }


/* Адаптивность при помощи переноса блоков на другой ряд */
.container-3 { /* третий родительский блок */
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap; /* flex-wrap - свойство задающее перемещение части блоков на новый ряд, если при уменьшении размеров экрана им не будет хватать места(включая отступы):
  nowrap - значение по умолчанию блоки не переносятся;
  wrap - блоки будут переноситься на новый ряд по мере необходимости, начиная с последнего;
  wrap-reverse - переносятся начиная с первого */
}


/*                                              flex-basis */

/*  flex-basis - свойство отвечает за базовый размер, это либо ширина(аналог width) если значение flex-direction это row, либо высота если значение column */

.container-b { background-color: #a33; border: 1px solid pink;
  display: flex;
}

.basis1 { background-color: pink; padding: 20px; margin: 20px;
  flex-basis: 500px; /* если элементы слишком большие, то flexbox уменьшает их все пропорционально, чтобы уместить на странице */
  /* При вертикальном расположении блоков материнский блок будет увеличиваться если высота внутренних слишком большая  */
}

.basis2 { background-color: pink; padding: 20px; margin: 20px;
  flex-basis: 200px; /* ширина всех блоков будет 200px, прилегают слева. Если значением flex-direction поставить row-reverse то блоки буду прилегать справа */
  /* При уменьшении размеров экрана в первую очередь это будет за счет пустого пространства и только потом начнут сжиматься внутренние блоки. */
}


/* Различные стандартные(не числовые) значения flex-basis; */
.container-b2 {
  list-style-type: none; /*  делаем список материнским блоком а его элементы внутренними */
  display: flex;
}
.flex {
  background: #6ab6d8; color: white;
  padding: 10px;
  border: 3px solid #2e86bb;
  text-align: center;
}
.flex1 { flex-basis: auto; }        /*  ??  */
.flex2 { flex-basis: max-content; } /* блок растягивается на всю ширину контента без переноса если это возможно*/
.flex3 { flex-basis: min-content; } /* контент переносится насколько возможно чтоб получить минимальную ширину блока */
.flex4 { flex-basis: fit-content; } /*  ??  */
.flex5 { flex-basis: content; }     /*  ??  */



/*                                              flex-grow и flex-shrink */

/* По умолчанию значения flex-grow и flex-shrink равны 0 */

.grow1 {
  flex-grow: 1; /* если для одного элемента прописать любое значение flex-grow то он займет все пустое пространство */
  /* При у меньшении экрана в первую очередь будет уменьшаться grow элемент, до тех пор пока он не станет как остальные, затем будут уменьшаться все равномерно */
}


.grow5 { flex-grow: 5; }
.grow10 { flex-grow: 10; }
/* У нас есть свободное пространство некого размера Npx. Теперь сложим наше соотношение 3 + 10 = 13 - сумма всех наших grow. Это количество частей на которое мы поделим свободное пространство Npx. Npx/13 это и будет одна часть, соотв одному элементу отойдет 3 таких части от свободного пространства, а другому 10 частей. */

.shrink { flex-shrink: 10; }
/* C того момента когда все grow-элементы сжались до одного размера(или изначально были одного), то данный элемент со свойством  flex-shrink сжимается сильнее остальных, если есть несколько shrink элементов то они сжимаются пропорционально значению, чем выше значение тем сильнее сжимаются */


/* ?? Общее flex свойство принимет 3 параметра в очередности 1. flex-grow  2. flex-shrink  3. flex-basis */
.some { flex: 1 6 200px; }

















/* */
