/* todo:
разбить на подфаилы по темам ??
transition - перенсти из псевдоклассов в отдельный блок
cursor: copy; Это не свойство текста а всего ?? потом проверить
*/

/* синтаксис комментария в CSS */
/* можно выделить часть кода в css файле и нажать Ctrl + / так комментировать эффективней и быстрее */

/* Очистите кэш страницы если не реагирует на изменения в css фаиле - ctrl + shift + R (Mac: cmd + shift + r) */


/*                                               Основы CSS */

/* CSS - Cascading Style Sheets - каскадная таблица стилей. Нужна для того чтобы придать оформление сайту. Все оформление можно делать и в HTML-коде, но использование стилей намного удобнее */

/* Синтаксис css стилей включает 2 основных элемента: */
  /* 1. Селектор(тут body) - он обращается к объектам в html-коде и указывает целевой элемент, которому назначается стиль */
  /* 2. Блок объявления стилей – подсказывает браузеру нужные правила форматирования. Блок стилей содержит свойства(тут font-family) - свойство опистывает тип стиля, далее через двоеточие указывается его значение(сам стиль) */
body { /* Фигурные скобки можно ставить по разному, можно например с новой строки */
	font-family: Arial;
  /* background-color:red;
	width: 100px; height: 60px; */  /* новые свойства можно писать как в строку так и в столбик. последовательность не важна */
	/* Если прописаны 2 одинаковых свойства, то сработает последнее */
}


@charset "UTF-8";
/* Указание типа кодировки(Возможно устарело) UTF-8  - универсальная кодировка для работы и с русским и английским*/


/*                                               Селекторы для выборки элементов */

/*     0. Универсальный селектор. Выбор всех html-объектов через селектор звездочки */
* {
	/*  Какието свойства, например убрать отступы по умолчанию */
	outline: none; /* убираем обводку по умолчанию, например у активных инпут полей */
}

/*     1. Выбор по имени/типу тега(присваивает стили ко всем тегам данного типа) */
h3 {
  background-color: yellow;
}

/*     2. Выбор по классу - присваивает стили ко всем тегам со значением атрибута class аналогичным имени селектора. Удобен тем что можно присвоить стили группе различных конкретных тегов */
.main_text {
  color: red;
}
/* теперь ко всем тегам к которым мы хотим применить это правило, мы дописываем атрибут class="main_text" */

/*     3. Выбор по идентификатору - присваивает стили конкретному объекту с уникальным id */
#text_in_p { /* значение айди в селекторе начинается с символа хэш(#). Желательно не называть именем тегов(старые брауз) */
  color: blue;
}

/*     4. Выбор по вложенным селекторам - присваивает стили объектом соотв конечной точке "пути" цепочки селекторов. Уровень вложенности указывать не обязательно полный если он достаточен  */
div p b {
  color: green;
}

/*     4а. Вложение различных типов селекторов выбора */
p.some_text { /* ?? Путь вложенности указываем без пробела ??  */
	color: blue;
}

/*     5. Группировка различных селекторов выбора(через запятую добавляем новые селекторы ) */
div p b, .any_text, #div_text_in_p {
  color: red;
}

/*     6. Мультиклассы(два и более класса селекторов для одного тега) */
.a.b {text-decoration: line-through;}  /* class="a b" */
.a { color: red;}
.b { color: blue;}

/*     7. Выбор по наличию атрибута */
[name] {color: green;} /* применяет стили к тегам у которых есть атрибут name */
[name=some_name] {text-decoration: line-through;} /* применяет стили к тегам у которых есть атрибут name со значением some_name */
div[name] {background-color: gray;} /* с вложением */

/*     8. Дочерние селекторы - в отличие от просто вложенных выбирают не все вложенные теги а только прямых наследников и не выбирают теги что идут внутри других тегов в этом материнском теге */
#example>i { /* Дочерние селекторы выбираются при помощи символа > */
	color: magenta;
}

/*     9. Соседние селекторы. Можно присваивать стили к типам селекторов которые идут сразу за другим типом селекторов */
span + b { /* Соседние селекторы выбираются при помощи символа + */
  color: #ccc051;
}


/*                                               Псевдоклассы и псевдоэлементы */

/* При помощи CSS мы можем обращаться к состояниям и определенным частям HTML блоков. Такое может происходить за счет различных псевдоэлементов и псевдоклассов */

.main_link { /* Стили для клааса main_link и описание некоторых существующих свойств */
	color: red;
	text-decoration: none;
	text-decoration-color: green;
}


/*     1. Псевдоклассы. Все псевдоклассы добавляются через двоеточие - : после селектора(применимо к любым типам селекторов) При помощи псевдоклассов мы можем управлять различными css свойствами для различных состояний какого либо объекта */


/* 1а. Псевдоклассы для ссылок: */

/*    :link - применяются исключительно для ссылок. Стили будут применены к ссылкам, на которые пользователь еще не переходил */
.main_link:link { color: #d38e8e; }

/*    :visited - псевдокласс применяющий стили к ссылке по которой мы уже переходили(остается в кэше после обновления страницы) */
.main_link:visited {
	text-decoration: line-through;
	color: gray;
}

/*    :hover - псевдокласс применяющий стили к объекту при наведении курсора на него */
.main_link:hover {
	color: blue;
	text-decoration: overline;
	text-decoration-color: red;

	cursor: pointer;

	-webkit-transition: all.6s ease; /* transition - свойство для плавности перехода hover и других эффектов */
	-moz-transition: all.6s ease;
	-o-transition: all.6s ease;
	-ms-transition: all.6s ease;
	transition: all.6s ease;
}

/*    :active - псевдокласс применяющий стили к объекту при нажатии на него */
.main_link:active { text-decoration: line-through; }

/* (ПОЯСНЕНИЕ ИЗ КОММЕНТОВ) visited должен стоять перед псевдоклассом hover, а тот в свою очередь перед active, а иначе будет работать некорректно. + если вы использовали ссылку из локальных файлов( фотка ) то она автоматом будет гореть как посещённая, поэтому попробуйте с обычной ссылкой на сайт( на неё наложиться visited только после открытия, а потом т.к в истории браузера вы посещали эту ссылку, то будет определяться как visited) */


/* 1b Псевдоклассы для полей: */

/*    :focus - псевдокласс применяющий стили к текстовому полю(input/textarea) когда оно активно */
input:focus {color: red} /* пока поле активно будет красным, а когда не активно черным(по умолчанию) */

/*    :disabled - псевдокласс применяющий стили к текстовому полю(input/textarea) когда оно содержит атрибут disabled */
input:disabled {}  /*    :anabled - аналогично для enabled;   :required - аналогично дя required(обязательные для заполнения) */


/* 1c Другие псевдоклассы:  */

/* :empty - псевдокласс применяет стили к пустым тегам */
/* p.text:empty { ...  } */

/* :not - псевдокласс применяет стили к объектам обратным к другому псевдоклассу указанному в скобках(Стили в псевдоклассе :not добавляются к элементам, которые не содержат селектор, указанный в псевдоклассе(любой тип седектора)), в данном случае это будут объекты не являющиеся пустыми */
p.text:not(:empty) {
	color: orange;
}

/* :first-of-type - псевдокласс применяет стили только к первому объекту с данным селектором */
/* :last-of-type - псевдокласс применяет стили только к последнему объекту с данным селектором */
/* :only-of-type - стили будут применены к объекту, если он единственный объект в теге. К примеру, у нас есть тег div и у него три тега p. В этом случае p:only-of-type не будет применен, так как в теге присутствует несколько таких тегов.*/
h2.h2:first-of-type {
	text-decoration: line-through;
}

/* :first-child/:last-child - Псевдокласс применяющий стили к первому/последнему дочернему элементу этого типа.  При этом, если в :first-of-type стили добавляются к первому указанному элементу, к примеру к тегу p, то здесь просто добавляется к самому первому элементу в блоке, то есть не идет учет по тегам. */
.child :first-child { background-color: red;} /* если между классом и псевдоклассом поставить пробел выберет из дочерних относительно указанного селектора тегов, а если не ставить то будет применять к тегам относящимся к данному селектору  */
.child :last-child { background-color: yellow;}
.child:first-child { background-color: silver;} /* а если не ставить пробед между селектором и псевдоэлементом, тогда применит стили к элементу заданному данным селектором если уже он сам является первым дочерним элементом некого блока уровнем выше  */
/* :nth-child(kn) - псевдокласс применяет стили к каждому k-тому дочернему элементу */
.nchild :nth-child(2n) { background-color: green;}

/* :has(> something) - Псевдокласс применяющий стили к элементу, который содержит другой элемент */
a:has(> b) {background-color: orange;}


/*     2. Псевдоэлементы. (применимо к любым типам селекторов, задается после псевдоклассов) При помощи псевдоэлементов мы можем работать с какой-то определенной частью текста внутри html-объекта. Ранее необходимо было обязательно для пседоэлементов два двоеточия. С приходом CSS3 этот момент был упрощен и теперь можно для всего прописывать лишь одно двоеточие(хотя более правильно будето всетаки 2)  */

/* ::after и ::before - псевдоэлементы добавляющие нефункциональный для пользователя текст до или после текста из тега и применить стили к этим допольнительным кусочкам текста. При помощи этих псевдоэлементов мы создаем текст как бы вне тега. Можно использовать с пустыми тегами, чтоб создавать полностью нефункциональный текст */
#after_before_id::after {
	content: '123'; /* content - свойство часто применяющееся к псевдоэлементам ::after и ::before, в значении этого свойства мы указываем какой текст будет выводиться после или до объекта */
	color: red; /* Далее все стили будут применяться только к этому дополнительному тексту (тут 123) */
	text-decoration: line-through;
	/* display: block; */  /* Так же тут применимо свойство display */
}
#after_before_id::before {
	content: attr(title); /* значением свойства content можно указать значение некого атрибута тега(тут title) */
	/* attr () предназначена для получения какого-либо атрибута из любого тега До CSS3 эта функция применялась только к свойству content, сейчас же её можно применять ко многим свойствам. */
	/* url - добавление объекта по ссылке на него. Если объекта по ссылке не будет, то будет подставлено пустое значение; */
	color: blue;
}

/* Псевдоэлементы пишутся после псевдоклассов */
p.text2:not(:empty)::after {
	content: 'cheto tam';
	color: orange;
}

/* ::first-letter - псевдоэлемент применяет стили только к первому символу в тексте */
p.f_sym::first-letter {color: red}
/* ::first-line - псевдоэлемент применяет стили только к первой строке */
p.f_lin::first-line {color: green}

/* ::selection - псевдоэлемент для выделенного(мышкой) текста(без селектора видимо для всего боди) */
::selection {color: #fff; background: #f58b8b;}
::-moz-selection {color: #fff; background: #f58b8b;} /* для отдельных браузеров мозила сафари итд */
::-webkit-selection {color: #fff; background: #f58b8b;}
::-ms-selection {color: #fff; background: #f58b8b;}



/*                                            Работа с фоновыми картинками  */

/* При помощи CSS можно устанавливать любой задний фон для всего сайта в целом или для определенных объектов. Вместо сплошного цвета на заднем фоне можно добавить картинку. */

/* Цвета помимо просто слова, можно задавать при помощи хэша RGB-hex, для этого можно воспользоваться например color picker в поиске гугла, выбрать там цвет и скопировать его хеш-код  */

/* 1. Установка фона через отдельные background-свойства */
body {
	background-color: #cad6eb; /* background-color - свойство для выбора цвета заднего фона объекта */
	/* transparent - если поставить в значение background-color то фон будет прозрачным */
	background-image: url('../img/klod.jpg');	/* background-image - свойство для выбора фоновой картинки объекта. Юрл-адрес картинки прописывается через синтаксис url(), это может быть и относительный адрес в нашем проекте, так и картинка из интернета. Всесто указания юрл можно поставить значение none - убирает задний фон. */
	background-repeat: repeat-y; /* background-repeat - свойство задающее способ повторения картинки(По умолчанию картинка растягивается на все пространство своего размера, насколько ей не хватает качества для заданного масштаба экрана и повторяется).
	no-repeat - не повторяется(все остальное пространство займет фон) Устанавливается в позицию заданную background-position;
	repeat    - повторяется;
	repeat-x  - повторяется по координате икс;
	repeat-y  - соотв по игрек;
	space     - будет повторятся пока не заполнит весь фон, при этом не будут резаться изображения. Если полностью изображения не заполнят фон, то между ними будут созданы пробелы;
	round     - будет повторятся пока не заполнит весь фон, при этом не будут резаться изображения. Если полностью изображения не заполнят фон, то браузер растянет изображение, чтобы они заполняли весь фон. */
	background-position: right top; /* background-position - свойство задающее расположение фоновой картинки. В качестве значений вы можете установить значение по горизонтали и/или вертикали.
	Горизонталь - left, center, right.
	Вертикаль   - top, center, bottom.
	Указывается следующим образом: left center, что означает 0% 50%, получается прижато к левому боку и по центру страницы */
}

/* 2. Установка фона через универсальное background свойство + Фиксированный задний фон. Свойство background может принимать до 5 свойств, при этом не важно в какой последовательности они будут указаны. */
#first {
	background: green url('../img/vot.jpg') no-repeat center center; /* background: - универсальное свойство в значениии которого можно указать значение всех отдельных background-свойств через пробел(тут по порядку: цвет фона, фоновая картинка, способ повторения, расположение по икс, расположение по игрек) */

	background-size: cover; /* background-size - задает размер фона относительно размера объекта(cover - растянуто на все пространство объекта даже если она маленькая, те исключает повторы) */
	-o-background-size: cover; /* дополнительно для оперы чтобы работало корректно */
  -moz-background-size: cover; /* дополнительно для мозилы */
  -webkit-background-size: cover; /* дополнительно для сафари */

	background-attachment: fixed; /* background-attachment --
	fixed - закрепляет картинку относительно экрана пользователя, соотв она всегда будет оставаться в одном положении и не двигаться при прокрутке экрана;
	scroll - является значением по умолчанию;
	relative - ?? */

	background-blend-mode: multiply; /* background-blend-mode - свойство указывающее сколько будет наложено слоев(multiply -множество слоев) теперь фоновая картинка и цвета фона будут накладываться друг на друга(в данном случае наложится зеленый фон тк он указан как фон) */

	height: 500px; /* height - задает высоту объекта(тут div) по вертикали(игрек) */
}



/*                                                Стили для текста */

/*  Применяются ко любым текстовым элементам на странице(любым тегам содержащим текст включая ссылки) */
/* https://gwfh.mranftl.com/fonts   -  сайт с шаблонами шрифтов для CSS */

.text_text {
	color: #000; /* color - свойство устанавливающее цвет для текста, цвет можно задать как словом так и RGB-hex-хэшем, #000 или #000000 - черный(стоит по умолчанию), #fff или #ffffff - белый */
	text-align: left; /* text-align - свойство позволяющее расположить текст относительно экрана по ширине:
	center  - по центру(центрируется каждая строка);
	right   - справа(значение по умолчанию);
	justify - растянутый по всей ширине страницы */
	font-size: 1.8em; /* font-size - свойство устанавливающее размер шрифта(по умолчанию обычно 16px). */
	text-indent: 1.1em; /* text-indent - свойство указывающее отступ для первой строки текста(визуально книжного абзаца) */
	font-style: italic; /* font-style - свойство позволяющее сделать текст наклонным(italic) */
	font-weight: bold; /* font-weight - свойство делающее шрифт жирным(bold). Можно настроить разную степень жирности(bolder или цифровыми значениями) но это работает не для всех шрифтов */
	font-family: Arial, sans-serif; /* font-family - свойство позволяющее изменить семейство шрифта(если нужны нестандартные доп шрифты то придется их подключить например при помощи https://fonts.google.com/) */
	/* sans-serif - подберет другой шрифт если на компьютере пользователя не поддерживается указанный */

	text-shadow: 1px 1px 10px red; /* тень(аура) для текста, в значениях 10px это размер распространения и дальше цвет */

	text-transform: capitalize; /* text-transform - свойство определяющее регистр символов.
	lowercase - все строчные;
	uppercase - все заглавные;
	capitalize - капиталайз для каждого слова;
	none - по умолчанию итд  */
	word-spacing: 10px; /* word-spacing - свойство задающее пространство между словами(отрицательное значение уменьшает пространство в минус от стандартного вплоть до перекрывания слов друг другом) */
	letter-spacing: -5px; /* letter-spacing - свойство задающее пространство между символами(отрицательное значение уменьшает пространство в минус от стандартного вплоть до перекрывания символов друг другом) */
	line-height: 50px; /* line-height - свойство задающее пространство между строками(отрицательного значения похоже нет, но перекрытие может быть если оно просто маленькое относительно шрифта) можно задавать в процентах */

	text-decoration: line-through; /* text-decoration - свойство определяющее тип подчеркивания у текста(по умолчанию у ссылок нижнее у текста никакое)
	none         - без подчеркивания,
	underline    - нижнее,
	overline     - верхнее(не всегда работает корректно),
	line-through - перечеркивание */
	text-decoration-color: yellow; /* text-decoration-color - свойство определяющее цвет линии подчеркивания */

	/* ???  Это не свойство текста а всего потом проверить */
	cursor: copy; /* cursor - свойство определяющее вид курсора при наведении на объект(по умолчанию зависит от типа объекта), например pointer - всегда палец как у ссылки по умолчанию.*/
	/* https://itproger.com/spravka/css3/cursor  описание всех видов курсоров */
	/* cursor: url('юрл_адрес_картинки');  -  так можно установить курсором любую картинку  */
}

/* Подключение дополнительных шрифтов при помощи https://fonts.google.com/ */
/* Выбираем шрифт далее либо скачиваем и помещаем его себе в проект, либо используем ссылку на сайт шрифтов - выбираем Type tecter -> выбираем набор опций для шрифта если они есть, даллее мы можем либо скопировать в тег head предложенный объект linc либо импортировать стили в наш css-фаил при помощи синтексиса @import ... скопировав предложенную строку(тут). Так же там будет указано как его вписать в font-family */
@import url('https://fonts.googleapis.com/css2?family=Chivo+Mono:ital,wght@0,300;1,600;1,800&family=Rubik+Gemstones&display=swap');
/* Мы выбрали 2 шрифта('Rubik Gemstones' и 'Chivo Mono') и дополнительно опции жирности 300, 600 и 800 для 'Chivo Mono' */
.text_text2 {
	font-size: 25px;
	/*font-family: 'Rubik Gemstones', cursive;*/
	font-family: 'Chivo Mono', monospace; /* такой способ значения свойства был указан в гугл фонтс('Chivo Mono' - сам шрифт, monospace - семейство) */
	font-weight: 800; /* Теперь мы можем выбирать те опции жирности которые есть в заданном шрифте */
}



/*                                                 Стили для блоков */

/* Любой сайт состоит из блоков, которые в отличие от строчных объектов по умолчанию занимают всю ширину экрана. Каждый блок может быть выделен тегом div или же каким-либо специальным тегом по типу: h1, header, footer, aside, main и так далее. С помощью CSS можно добавить множество стилей к блоку и создать из блока практически любую фигуру. */

/* Многие свойства работают только с блочными объекатами */

.block_stile {
	background: #bec320;

	height: 200px; /* height - свойство задает высоту блока(работает только с блочными объектами) по вертикали(игрек) */
	width: 250px; /* width - свойство задает ширину блока(работает только с блочными объектами) по горизонтали(икс) */
	max-width: 400px; /* max-width - свойство указывает максимальную ширину объекта, те ширина объекта не увеличивается если мы раздвигаем страницу(если указана в процентах). Если указать в процентах то блок не будет вылезать за материнский блок(адаптивность) */
	max-height: 400px;
	min-width: 100px; /* Если указать width/max-width(тоже с высотой) то если контент внутри блока больше этих размеров, то он будет вылезать, а если указать только минимальный размер то блок будет растягиваться при увеличении контента */

	line-height: 200px; /* Указав расстояние между строками равное значению height, текст расположится в центре блока по высоте(если он однострочный конечно, а иначе след строка вылезет) */

	/* Добавление обводки может производиться универсальным свойством border или отдельными border-... свойствами или комбинацией универсального и отдельных свойств */
	border: 7px dotted #386738; /* border - универсальное свойство, в которое можно поместить значения (5 ??) различных подствойств. Тут по порядку:
	ширина обводки в пикселях;
	тип обводки: solid - сплошная, dashed - прерывистая/пунктирная, dotted - точечная, double - двойная сплошная, groove - объемная вдавленная, ridge - выпуклая объемная, inset - весь блок кажется вдавленным, outset - весь блок кажется выпуклым итд;
	цвет обводки;  */
	border-bottom: 0; /* border-bottom(/-top/-left/-right) - свойство добавляющее/изменяющее обводку с определенной стороны, можно комбинировать с универсальным свойством. Все значения как и в универсальном. Значение 0 - убирает обводку */
	border-top-style: double; /* Так же можно записывать подсвойства и в само свойство через дефис, если нужно одно конкретное */

	border-radius: 15px 50% 50px; /* border-radius - свойство устанавливающее скругление углов объекта. Если указываем одно значение - скругляет все углы; если 2 значения то 1е скругляет верхний левый и нижний правый, а второе другие два; если указываем три значения, то 1е - верхний левый, 2е - верхний правый и нижний левый, 3е - нижний правый; если 4 свойства то каждое по частовой от верхнего левого угла */

	box-sizing: border-box; /* устанавливает что значение (тут обводки) входит в ширину блока и не будет ее менять. для отступов padding-box, для обводки border-box */

	opacity: 0.8; /* opacity - свойство добавляющее прозрачность(работает с любыми объектами а не только с блоками) при помощи коэфициэнта в котором 1 - полностью непрозрачный, а 0 - полностью прозрачный, те невидимый */

	margin: 20px 25px; /* margin - универсальное свойство меняющее внешние отступы(от других объектов). Можно вписать до 4 значений, работает так же как border-radius только начинается от верхней стороны */
	/* margin: 0 auto; - в сочетании с шириной меньше 100% центрирует блок */
	margin-top: 30px; /* margin(-top/...) - свойство меняющее внешние отступы для отдельной стороны */
	padding: 20px; /* padding - универсальное свойство меняющее внутренние отступы от границ объекта до содержимого тега(текста). Добавляя отступы меняет визуальный размер объекта. Можно записать до 4х значений аналогично margin */
	padding-left: 10px;

	/* Любой браузер добавляет отступы по умолчанию для того чтобы их убрать, то можно установить margin и padding со значением 0 для необходимого тега, удобно установить для всех тегов при помощи селектора звездочка(*) чтобы потом добавлять только для нужных нам блоков */

	/* Часто необходимо скрыть какой-либо объект со страницы сайта или показать его в формате: списка, таблицы, блока, блока в одну линию и так далее. Для редактирования свойства элемента можно использовать свойство display. */
	display: block; /* display - свойство меняющее тип отображения объекта(inline - строчный, block - блочный, table - табличный, list-item - делает элемент частью(li) списка, none - объекты не будут принимать никакие свойства те не будут отображаться и под объект не будет выделено место) соответсвенно меняются и возможные к применгению свойства для него */

	/*visibility: hidden;*/  /* просто скрывает объект но выделенное под него место остается */
}

.borders { /* Пример рисунка при помощи отдельного свойства border-color */
 width: 0; height: 0; /* При нулевых размерах самого объекта он будет полностью состоять из обводки */
 border: 100px solid;
 border-color: #FF5B45 #1D532A #6DCDF7 #FFE02E; /* border-color - свойство для указания цвета обводки */
}



/*                                               Стили для полей ввода */

#some_input {
	outline-color: red; /* outline-color - изменяет цвет обводки инпут полей когда они активны */
	outline: none; /* outline - изменяет обводку инпут полей когда они активны(тут none - убирает обводку по умолчанию) */
}

#some_textarea {
	resize: horizontal;
	/* Свойство resize можно применять только к текстовому полю, который записывается через тег textarea. Свойство указывает как пользователь может изменять ширину и высоту текстового поля: none - нельзя изменить размеры textarea; vertical - можно изменить размеры textarea только по вертикали (по высоте); horizontal - можно изменить размеры textarea только по горизонтали (по ширине); both - можно изменить размеры textarea как ширину, так и высоту. */
}

#some_input:hover, #some_textarea:hover {
	box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(255, 0, 0, 0.6);
	/* подсветка границы поля, хз зачем тут - inset 0 1px 1px rgba(0, 0, 0, 0.075) */
}

#some_input:valid, #some_textarea:valid { /* :valid - псевдокласс для незаполненного поля ???? */
	/* background-color: green; */
}


/*                                               Стили для списков */

#list {margin: 20px}

#list ul {
	list-style: initial; /* list-style - свойство для стилей списков, none - указываем что их не будет */
  list-style-position: outside; /* outside - по умолчанию, inside - делает автоотступ изза границ блока в который вложен список и соотв значки перед элементами будут видны(похоже на чтото устаревшее) */
  list-style-type: armenian; /* изменение значков перед элементами списка(для обоих типов списка) */
  list-style-image: url('../img/kon.jpg'); /* можно указать картинку вместо значков списка(если слишком большая то визуально увеличит список) */
}


/*                                                Различные свойства и функции */

/* 1.  Свойство all используется для удаления всех свойств или же унаследования всех свойств из свойства родителя. Поскольку он служит только для удаления или же унаследования стилей, то он может принимать всего три значения: inherit, initial или же unset. Это новое свойство, которое работает только в новых версиях современных браузеров. */
.all1 p {color: red}
.all1 h2 {color:blue}
.all1 p, .all1 h2 {all: initial} /*  Удалились все свойства в том числе и свойства тегов абзац и заголовок(похоже ииза браузера) */

/* 2.  Функция blur() предназначена для создания эффекта размытия. Функция будет работать корректно со всеми дочерними тегами body. Размытие создается по Гауссу. В качестве размера размытия можно вписать любые CSS3 единицы измерения, к примеру 5px. Чем больше это значение, тем больше будет размытие. Синтаксис функции: filter: blur(Размер); */
#css-course {
  -webkit-filter: blur(2px);
  filter: blur(2px);
}

/* 3. Функция calc () предназначена для подсчета значений. Так в этой функции вы можете вычислить размер, угол, время.
Можно применять следующие математические операции:
сложение (+) - margin: calc (12px + 45px)
вычитание (-) - width: calc(100% - 56px)
умножение (*) - height: calc(20em * 1.2)
деление (/) - padding: calc (57px / 3). Деление на ноль невозможно.
Функция поддерживается всеми современными браузерами. Можно спокойно использовать в создании сайта.
Синтаксис функции:свойство: calc(математическая операция); */

/* 4. Свойство caption-side задает положение заголовка таблицы, которое задается при помощи тега caption.  При помощи этого свойства вы можете лишь задать вертикальное положение: сверху или снизу таблицы. Горизонтальное выравнивание происходит при помощи свойства text-align. */
#some_table caption {
	caption-side: bottom; /*  Значение top по-умолчанию и означает что заголовок таблицы будет сверху, а значение bottom говорит о том, что заголовок будет под таблицей. */
}

/* 5. !important применяется для явного указания приоритета. К примеру, если указать его для какого-либо свойства, то его применение будет в приоритете, что означает что именно оно будут использовано.
В этом примере цвет фона будет установлен как lightblue, так как там установлен приоритет */
#important_p { background-color: lightblue!important;}
#important_p { background-color: red;}

/* 6. Значение inherit позволяет установить свойство точно таким же, как и свойство в родительском элементе. Все это будет работать исключительно, если в родительском элементе это свойство установлено, иначе результат вы не увидите. Синтаксис значения: Свойство: inherit; #block>p {padding: inherit;} */
.mother_inherit, .doter_inherit { border: 1px solid red;}
.mother_inherit {padding: 15px;}
.doter_inherit {padding: inherit;} /* дочерний элемен принял свойство padding: 15px; */


/* 7. Значение initial позволяет установить значение по умолчанию. Это означает, что применив это значение к какому-либо свойству вы получите свойство со значением установленным браузером   Свойство: initial;  */
#init_p{ font-size: 1.8em;}
#init_p>span{ font-size: initial; }



/*                                      Позиционирование блоков(свойства: float, z-index, overflow) */

/* Блочные объекты по умолчанию располагаются друг под другом вертикально(тк занимают 100% ширины экрана). При помощи CSS свойств мы можем менять расположение блоков относительно друг друга и на странице в целом */

.block { width: 200px; height: 200px; margin: 20px;	} /* Общие стили для блоков */

/* Изменение расположения объектов при помощи свойства float, после чего блок будет позиционироваться с какой-либо стороны, а все дополнительные элементы будут обтекать его. Уместнее всего использовать float для обтекания картинки текстом но раньше при помощи него делалось все позиционирование */
#first_block {
	background: red;
	float: left; /* left(или right/none) - значение свойства float, означает что блок #first_block будет прижат к левой стороне и другие объекты(не только блоки) его смогут обтекать справа(но для этого им тоже нужно добавить свойство float(только блокам другие объекты будут обтекать и так), а иначе они будут наслаиваться) */
}
#second_block {
	background: blue;
	float: left; /* Теперь оба блока позиционируются слева друг за другом(след относительно предыдущего на одной "линии") */
}
#third_block {
	background: green;
	float: right; /* Позиционируем 3й блок справа */
	/* clear: right;*/ /* Запрещаем позиционирование справа от этого блока */
}

/* При добавлении внутреннего блока в html коде, чтобы он корректно отображался ему тоже можно добавть float */


/* Исправляем проблемы со свойством float у предыдущего блока(след блок без свойства float наложится на него). "добавить пустой div со стилем clear: both перед следующим блоком" */
#clear_block {
	clear: both; /* clear: - свойство clear необходимо для удаления действия float с определенной стороны.(удаляет обтекание объекта текстом, картинками и прочем с какой-либо стороны.) left - удаление обтекания с левой стороны; right - удаление обтекания с правой стороны; both - удаление обтекания с обеих сторон; none - значение по-умолчанию (обтекание со всех сторон). */
} /* Размещаем пустой блок запрещающий свойство float в обе стороны от себя */


/*         Использование слоев(иерархия слоев) */

/* По умолчанию у более раннего(в расположении в html-коде) блока слой при наложении будет считаться более низким, соотв он будет помещаться под следующий блок. Это можно менять при помощи свойств position и z-index */
#f_block {
	background: magenta;
	width: 300px; height: 300px;

	position: relative; /* свойство z-index не будет работать без свойства position */
	z-index: 1; /* Ставим z-index с более высоким значением чем в след блоке и теперь этот блок будет поверх следующего */
}
#s_block {
	background: yellow;
	width: 300px; height: 300px;

	position: relative;
	top: -150px; /* изменяем относительное положение блока при помощи свойства position чтобы он наслаивался на предыдущий(изначальное положение блока остается этим блоком те будет промежуток визуально) */
	right: -150px;
	z-index: 0; /* Ставим z-index с более низким значением чем в пред блоке и теперь этот блок будет под предыдущим(можно указывать отрицательные значения) */
}


/*         Позиционирование элементов внутри блока(свойство overflow) */
/* Если для блока указать ширину и высоту, то находящийся внутри блока контент не всегда может помещаться в заданные рамки. Чтобы указать правило отображения контента внутри блока можно использовать свойство overflow. При этом вы можете добавлять overflow для конкретных осей. Так, overflow-y будет применять значения только по оси y, а overflow-x только по оси x. */
#block_text1, #block_text2, #block_text3, #block_text4 {
	height: 100px; width: 200px;
	color: white; background-color: gray;
	border: 5px solid magenta;
	margin: 30px;
	float: left;
} /* Изначально текст слишком большой для данных блоков и вылезает за их границы по высоте */

#block_text2 {
	overflow: hidden; /* overflow - свойство позиционирующее объеты(тут текст) внутри блока. visible - значение по умолчанию элементы за границами блока отображаются; hidden - элементы которые вылезают скрыты; scroll - элементы которые вылезает скрыты и есть полосы прокрутки(и горизонтальной и вертикальной) чтобы их посмотреть; auto - добавляет только те полосы прокрутки которые необходимы для данных соотношений размеров блока и элементов внутри него */
}
#block_text3 {overflow: scroll;}
#block_text4 {overflow: auto;}








/* http://www.justinaguilar.com/animations/index.html  сайт анимаций для css3 */
